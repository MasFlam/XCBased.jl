const EVENT_TYPES = [
	XCBKeyPressEvent,
	XCBKeyReleaseEvent,
	XCBButtonPressEvent,
	XCBButtonReleaseEvent,
	XCBMotionNotifyEvent,
	XCBEnterNotifyEvent,
	XCBLeaveNotifyEvent,
	XCBFocusInEvent,
	XCBFocusOutEvent,
	XCBKeymapNotifyEvent,
	XCBExposeEvent,
	XCBGraphicsExposureEvent,
	XCBNoExposureEvent,
	XCBVisibilityNotifyEvent,
	XCBCreateNotifyEvent,
	XCBDestroyNotifyEvent,
	XCBUnmapNotifyEvent,
	XCBMapNotifyEvent,
	XCBMapRequestEvent,
	XCBReparentNotifyEvent,
	XCBConfigureNotifyEvent,
	XCBGravityNotifyEvent,
	XCBResizeRequestEvent,
	XCBConfigureRequestEvent,
	XCBCirculateNotifyEvent,
	XCBCirculateRequestEvent,
	XCBPropertyNotifyEvent,
	XCBSelectionClearEvent,
	XCBSelectionRequestEvent,
	XCBSelectionNotifyEvent,
	XCBColormapNotifyEvent,
	XCBMappingNotifyEvent,
	XCBClientMessageEvent
]

# returns (the event, was it generated by a SendEvent)
function wait_for_event(conn:: XCBConnection):: Tuple{XCBEvent, Bool}
	evptr = LibXCB.xcb_wait_for_event(conn.handle)
	ev = unsafe_load(evptr)
	
	event_type = ev.response_type & 0x7f
	2 <= event_type <= 34 && error("unknown event type: $event_type (response_type = $(ev.response_type))")
	
	event = EVENT_TYPES[event_type - 1](evptr)
	Libc.free(evptr)
	
	event, ev.response_type & 0x80 != 0
end

# returns (the event, was it generated by a SendEvent) or nothing if there is no event ready
function poll_for_event(conn:: XCBConnection):: Union{Tuple{XCBEvent, Bool}, Nothing}
	evptr = LibXCB.xcb_poll_for_event(conn.handle)
	evptr == C_NULL && return nothing
	ev = unsafe_load(evptr)
	
	event_type = ev.response_type & 0x7f
	2 <= event_type <= 34 && error("unknown event type: $event_type (response_type = $(ev.response_type))")
	
	event = EVENT_TYPES[event_type - 1](evptr)
	Libc.free(evptr)
	
	event, ev.response_type & 0x80 != 0
end
